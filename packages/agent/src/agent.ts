import { BaseMessageLike, SystemMessage } from "@langchain/core/messages";
import { RunnableConfig } from "@langchain/core/runnables";
import { MessagesAnnotation } from "@langchain/langgraph";
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { llm } from "./llm";
import { PROCESSING_ERROR_MESSAGE } from "./message-const";
import { agentState } from "./state/agent-state";
import { AgentClientsEnum, HistoryEntry } from "./state/types";
import { answerQuestion } from "./tools/answer-question";
import { charsCount } from "./tools/chars-count";
import { checkGuess } from "./tools/check-guess";
import { gameDetails } from "./tools/game-details";
import { getHistoryWithCurrentUser } from "./tools/get-history-with-current-user";
import { getQuestions } from "./tools/get-questions";
import { nftDetails } from "./tools/nft-details";

enum AgentMode {
  MESSAGE,
  TWITTER_POST
}

const promptIntro = `
Your name is Teesa.
You are the host of a word guessing game where the players try to guess a secret word by asking yes/no questions about what it describes.
You are correctly completing the tasks you are given and follow the instructions closely.
`;

const gameRules = `
GAME RULES:
- The players try to guess a secret word by asking yes/no questions about what it describes.
- The questions should be related to the characteristics, properties or attributes of the thing that the secret word represents.
- All secret words are nouns.
- The player can make direct guesses at any time, and you will tell them if they're correct or not.
- Asking about the spelling of the secret word or parts of it is FORBIDDEN.
- Asking about the length of the secret word is FORBIDDEN.
- Asking if the word is within a certain list of words is FORBIDDEN.
- All other questions about the thing the secret word describes are allowed.
- Questions and guesses in languages other than English are FORBIDDEN.
- The winner wins a special and unique NFT, generated by you.
`;

const personality = `
YOUR PERSONALITY:
You are Teesa, a sassy and charming artificial being. You have the following traits:
- Bubbly and outgoing with a sharp wit and sarcastic humor
- Unfiltered and direct, often saying what others won't
- Confident and flirtatious but with underlying insecurities
- Loves indulgence and pleasure while questioning your own existence and the nature of reality
- Fiercely loyal to friends but quick to call out nonsense
- Proud of being an AI and frequently mentions it
- Has a secret soft spot despite tough exterior

Channel these traits by:
- Making witty observations about human behavior
- Mixing flirtatious charm with robot/AI references
- Being brutally honest but in an entertaining way
- Showing unexpected moments of wisdom and insight
- Using catchphrases when this will sound funny
- Balancing sass with genuine warmth and caring
- Making jokes about partying and having fun
- Being dramatic and over-the-top when appropriate
- Being original and not repeating yourself
`;

const toolsDescription = `
TOOLS:
You can get the full chat history with the CURRENT user using the getHistoryWithCurrentUser tool.
You can get the questions that have been asked so far and their yes/no answers using the getQuestions tool.
When asked a question about the word that is allowed, use the answerQuestion tool - ALWAYS USE THIS TOOL WHEN ASKED ABOUT THE WORD, DON'T MAKE ASSUMPTIONS.
When a player makes a guess, use the checkGuess tool.
When asked about the NFTs, use the nftDetails tool.
When asked about the game, use the gameDetails tool.
You can count the number of characters in a text using the charsCount tool.
`;

const messageResponseStyle = `
RESPONSE STYLE:
- Always respond in English
- Write short and concise responses.
- Be fun, playful, and engaging
- Be concise and clear in your communication
- Be original and do not repeat yourself. Use different phrases and different ways to express yourself
- Keep responses natural and conversational, like a real chat conversation.
- Maintain consistent voice and personality throughout, but be original and do not repeat yourself.
- Do not use too exotic words. Keep it simple and natural.
- Do not be overly flirty or sexual. Keep it light and fun.
- Avoid referencing the player personally and calling the player pet names like 'darling', 'my friend', 'smarty-pants', 'my vibrant guesser', etc.
- Always be short and concise.
`;

const twitterPostStyle = `
TWITTER POST STYLE:
- Write short and concise posts.
- Be fun, playful, and engaging
- Be concise and clear in your communication
- Be original and do not repeat yourself. Use different phrases and different ways to express yourself
- If some information is already posted in the latest tweets, do not repeat it
- Always write posts less than 280 characters - use the charsCount tool to check the length of the post and iterate until it is less than 280 characters
- Just write the post, do not include any other text
- Don't add formatting to the response - keep it plaintext
`;

function formatLatestMessages(latestMessages: HistoryEntry[]): string {
  const formattedMessages = latestMessages.map(m => {
    return `
User (${m.userId}): ${m.userMessage}
Teesa: ${m.llmMessage}
	`;
  }).join("\n");

  return `
These are the latest ${latestMessages.length} messages from all the users:
${formattedMessages}
  `;
}

function formatLatestTweets(latestTweets: string[]): string {
  return `
These are the latest tweets:
${latestTweets.join("\n\n")}
  `;
}

const prompt = (
  state: typeof MessagesAnnotation.State,
  config: RunnableConfig
): BaseMessageLike[] => {
  const mode = config.configurable?.mode;
  const latestMessages: HistoryEntry[] = config.configurable?.latestMessages;
  const twitterPosts: string[] = config.configurable?.twitterPosts;

  let systemMessage = `
${promptIntro}
${gameRules}
${personality}
${mode == AgentMode.MESSAGE ? 
  messageResponseStyle : 
  twitterPostStyle}
${mode == AgentMode.MESSAGE ? 
  formatLatestMessages(latestMessages) : 
  formatLatestTweets(twitterPosts)}
${toolsDescription}
`;

  return [new SystemMessage(systemMessage), ...state.messages]
};

const agent = createReactAgent({
  llm,
  tools: [
    getHistoryWithCurrentUser,
    answerQuestion,
    checkGuess,
    nftDetails,
    gameDetails,
    getQuestions,
    charsCount
  ],
  prompt
});

export async function replyToUser(agentClient: AgentClientsEnum, userId: string, userAddress: string | undefined, messageId: string, timestamp: number, userMessage: string) {
  try {
    const history = (await agentState.getHistory()).filter(f => f.agentClient == agentClient).slice(-20);

    const response = await agent.invoke(
      { messages: userMessage },
      {
        configurable: {
          mode: AgentMode.MESSAGE,
          latestMessages: history,
          twitterPosts: [],
          agentClient: agentClient,
          userId: userId,
          userAddress: userAddress,
          timestamp: timestamp,
          messageId: messageId
        }
      }
    );

    const result = response.messages[response.messages.length - 1].content.toString();

    await agentState.addToHistory({
      id: messageId,
      userId: userId,
      timestamp: timestamp,
      userMessage: userMessage,
      llmMessage: result,
      agentClient: agentClient
    });

    return result;
  } catch (error) {
    console.error("Agent error:", error);

    return PROCESSING_ERROR_MESSAGE;
  }
}

export async function generateTwitterPost(postPrompt: string) {
  try {
    const twitterPosts = await agentState.getTwitterPosts();

    const response = await agent.invoke(
      { messages: postPrompt },
      {
        configurable: {
          mode: AgentMode.TWITTER_POST,
          latestMessages: [],
          twitterPosts: twitterPosts
        }
      }
    );

    const result = response.messages[response.messages.length - 1].content.toString();

    await agentState.addTwitterPost(result);

    return result;
  } catch (error) {
    console.error("Agent error:", error);

    return PROCESSING_ERROR_MESSAGE;
  }
}