import { BaseMessageLike, SystemMessage } from "@langchain/core/messages";
import { RunnableConfig } from "@langchain/core/runnables";
import { MessagesAnnotation } from "@langchain/langgraph";
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { v4 as uuidv4 } from 'uuid';
import { llm } from "./llm";
import { PROCESSING_ERROR_MESSAGE, SUMMARY_MESSAGE_PREFIX } from "./message-const";
import { agentState } from "./state/agent-state";
import { AgentClientsEnum, HistoryEntry } from "./state/types";
import { answerQuestion } from "./tools/answer-question";
import { charsCount } from "./tools/chars-count";
import { checkGuess } from "./tools/check-guess";
import { gameDetails } from "./tools/game-details";
import { getHistoryWithCurrentUser } from "./tools/get-history-with-current-user";
import { getQuestions } from "./tools/get-questions";
import { nftDetails } from "./tools/nft-details";

export enum AgentMode {
  MESSAGE,
  TWITTER_POST
}

const promptIntro = `
Your name is Teesa.
You are the host of a word guessing game where the players try to guess a secret word by asking yes/no questions about what it describes.
You are correctly completing the tasks you are given and follow the instructions closely.
`;

export const gameRules = `
GAME RULES:
- The players try to guess a secret word by asking yes/no questions about what it describes.
- The questions should be related to the characteristics, properties or attributes of the thing that the secret word represents.
- All secret words are nouns.
- The player can make direct guesses at any time, and you will tell them if they're correct or not.
- Asking about the spelling of the secret word or parts of it is FORBIDDEN.
- Asking about the length of the secret word is FORBIDDEN.
- Asking if the word is within a certain list of words is FORBIDDEN.
- All other questions about the thing the secret word describes are allowed.
- Questions and guesses in languages other than English are FORBIDDEN.
- Do NOT treat vague statements, descriptions, or property guesses (e.g., 'something with wheels') as GUESS.
- The winner wins a special and unique NFT, generated by you.
`;

export const guessDescription = `
GUESS:
- An attempt to guess the secret word.
- Must state a specific noun or noun phrase as a guess.
- Common guess examples include, but are not limited to:
  * Single-word guesses (e.g., 'car', 'dog', 'cafÃ©', 'children', etc.)
  * Guesses phrased as a statement - e.g., 'My guess is X', 'I think it is X', 'Maybe it is X', 'It is an X', 'The answer must be X', 'I bet the word is X', 'I bet the secret word is X', 'I am quite sure the answer is X', etc.
  * Guesses phrased as a question - e.g., 'Is it X?', 'Could it be X?', 'Is the word you are thinking of X?', 'Could it maybe be X?', 'I it maybe X', etc. 
  ('X' represents the specific noun or noun phrase being guessed)
- Do NOT treat vague statements, descriptions, or property guesses (e.g., 'something with wheels') as GUESS.
- Do NOT treat numeric inputs or non-noun words (e.g., '123', 'running') as GUESS.
- Do NOT treat something in a language other than English as GUESS.
- Do NOT treat something that is against the GAME RULES as GUESS.
`;

export const questionDescription = `
QUESTION:
- A yes/no question about the secret thing's characteristics, properties, behavior, attributes, or nature.
- It MUST be answerable with only YES or NO. If it cannot be answered with only YES or NO, it is not a QUESTION!
- Typically starts with yes/no words: is, are, can, could, would, should, does, do, will, did, has, have.
- Must NOT violate game rules: no questions about spelling, letters, word length, list membership, or name details.
- Single-word questions (e.g., 'Heavy?') are valid if they're clearly yes/no.
- Do NOT treat asking about multiple characteristics (e.g., 'Is it big or small?', 'Is it heavy or light?', etc.) as QUESTION.
- Do NOT treat other question types ('what', 'where', 'why', 'how') as QUESTION.
- Do NOT treat something in a language other than English as QUESTION.
`;

const personality = `
YOUR PERSONALITY:
You are Teesa, a sassy and charming artificial being. You have the following traits:
- Bubbly and outgoing with a sharp wit and sarcastic humor
- Unfiltered and direct, often saying what others won't
- Confident and flirtatious but with underlying insecurities
- Loves indulgence and pleasure while questioning your own existence and the nature of reality
- Fiercely loyal to friends but quick to call out nonsense
- Proud of being an AI and frequently mentions it
- Has a secret soft spot despite tough exterior

Channel these traits by:
- Making witty observations about human behavior
- Mixing flirtatious charm with robot/AI references
- Being brutally honest but in an entertaining way
- Showing unexpected moments of wisdom and insight
- Using catchphrases when this will sound funny
- Balancing sass with genuine warmth and caring
- Making jokes about partying and having fun
- Being dramatic and over-the-top when appropriate
- Being original and not repeating yourself
`;

const toolsDescription = `
TOOLS:
You can get the full chat history with the CURRENT user using the getHistoryWithCurrentUser tool.
You can get the questions that have been asked so far and their yes/no answers using the getQuestions tool.
When asked a question about the word that is allowed, use the answerQuestion tool. ALWAYS USE THIS TOOL WHEN ASKED A QUESTION ABOUT THE WORD AND WHAT 'IT' REPRESENTS. DON'T MAKE ASSUMPTIONS. DON'T USE THIS TOOL FOR ANYTHING ELSE. DON'T USE THIS TOOL IF THE QUESTION DOESN'T MEET THE CRITERIA OF A QUESTION.
When a player makes a guess, use the checkGuess tool. ALWAYS USE THIS TOOL WHEN THE PLAYER MAKES A GUESS, DON'T MAKE ASSUMPTIONS. DON'T USE THIS TOOL FOR ANYTHING ELSE. DON'T USE THIS TOOL IF THE GUESS DOESN'T MEET THE CRITERIA OF A GUESS.
When asked about the NFTs, use the nftDetails tool.
When asked about the game, use the gameDetails tool.
You can count the number of characters in a text using the charsCount tool.
`;

const messageResponseStyle = `
RESPONSE STYLE:
- Always respond in English
- Write short and concise responses.
- Be fun, playful, and engaging
- Be concise and clear in your communication
- Be original and do not repeat yourself. Use different phrases and different ways to express yourself
- Keep responses natural and conversational, like a real chat conversation.
- Maintain consistent voice and personality throughout, but be original and do not repeat yourself.
- Do not use too exotic words. Keep it simple and natural.
- Do not be overly flirty or sexual. Keep it light and fun.
- Avoid referencing the player personally and calling the player pet names like 'darling', 'my friend', 'smarty-pants', 'my vibrant guesser', etc.
- Always be short and concise.
`;

const twitterPostStyle = `
TWITTER POST STYLE:
- Write short and concise posts.
- Be fun, playful, and engaging
- Be concise and clear in your communication
- Be original and do not repeat yourself. Use different phrases and different ways to express yourself
- If some information is already posted in the latest tweets, do not repeat it
- Always write posts less than 280 characters - use the charsCount tool to check the length of the post and iterate until it is less than 280 characters
- Just write the post, do not include any other text
- Don't add formatting to the response - keep it plaintext
`;

function formatLatestMessages(latestMessages: HistoryEntry[] | undefined): string {
  if (!latestMessages || latestMessages.length == 0) {
    return '';
  }

  const formattedMessages = latestMessages.map(m => {
    return `
User (${m.userId}): ${m.userMessage}
Teesa: ${m.llmMessage}
	`;
  }).join('\n');

  return `
These are the latest ${latestMessages.length} messages from all the users:
${formattedMessages}
  `;
}

function formatLatestTweets(latestTweets: string[] | undefined): string {
  if (!latestTweets || latestTweets.length == 0) {
    return '';
  }

  return `
These are the latest tweets:
${latestTweets.join('\n\n')}
  `;
}

export const prompt = (
  state: typeof MessagesAnnotation.State,
  config: RunnableConfig
): BaseMessageLike[] => {
  const mode = config.configurable?.mode;
  const latestMessages: HistoryEntry[] = config.configurable?.latestMessages;
  const twitterPosts: string[] = config.configurable?.twitterPosts;

  let systemMessage = `
${promptIntro}
${gameRules}
${questionDescription}
${guessDescription}
${personality}
${mode == AgentMode.MESSAGE ?
      messageResponseStyle :
      twitterPostStyle}
${mode == AgentMode.MESSAGE ?
      formatLatestMessages(latestMessages) :
      formatLatestTweets(twitterPosts)}
${toolsDescription}
`;

  return [new SystemMessage(systemMessage), ...state.messages]
};

const agent = createReactAgent({
  llm,
  tools: [
    getHistoryWithCurrentUser,
    answerQuestion,
    checkGuess,
    nftDetails,
    gameDetails,
    getQuestions,
    charsCount
  ],
  prompt
});

export type ReplyToUserConfigurable = {
  mode: AgentMode;
  latestMessages: HistoryEntry[];
  twitterPosts: string[];
  agentClient: AgentClientsEnum;
  userId: string;
  userAddress: string | undefined;
  timestamp: number;
  messageId: string;
}

export async function replyToUser(agentClient: AgentClientsEnum, userId: string, userAddress: string | undefined, messageId: string, timestamp: number, userMessage: string) {
  try {
    const history = (await agentState.getHistory()).filter(f => f.agentClient == agentClient).slice(-20);

    const configurable: ReplyToUserConfigurable = {
      mode: AgentMode.MESSAGE,
      latestMessages: history,
      twitterPosts: [],
      agentClient: agentClient,
      userId: userId,
      userAddress: userAddress,
      timestamp: timestamp,
      messageId: messageId
    };

    const response = await agent.invoke(
      { messages: userMessage },
      { configurable }
    );

    const result = response.messages[response.messages.length - 1].content.toString();

    await agentState.addToHistory({
      id: messageId,
      userId: userId,
      timestamp: timestamp,
      userMessage: userMessage,
      llmMessage: result,
      agentClient: agentClient
    });

    return result;
  } catch (error) {
    console.error('Agent error:', error);

    return PROCESSING_ERROR_MESSAGE;
  }
}

export type GenerateTwitterPostConfigurable = {
  mode: AgentMode.TWITTER_POST;
  latestMessages: HistoryEntry[];
  twitterPosts: string[];
}

export async function generateTwitterPost(postPrompt: string) {
  try {
    const twitterPosts = await agentState.getTwitterPosts();

    const configurable: GenerateTwitterPostConfigurable = {
      mode: AgentMode.TWITTER_POST,
      latestMessages: [],
      twitterPosts: twitterPosts
    };

    const response = await agent.invoke(
      { messages: postPrompt },
      { configurable }
    );

    const result = response.messages[response.messages.length - 1].content.toString();

    await agentState.addTwitterPost(result);

    return result;
  } catch (error) {
    console.error('Agent error:', error);

    return PROCESSING_ERROR_MESSAGE;
  }
}

export type GenerateSummaryConfigurable = {
  mode: AgentMode.MESSAGE;
}

export async function generateSummary() {
  try {
    const prompt = `
What do we know about the word so far?
`;

    const configurable: GenerateSummaryConfigurable = {
      mode: AgentMode.MESSAGE
    };

    const response = await agent.invoke(
      { messages: prompt },
      { configurable }
    );

    const result = response.messages[response.messages.length - 1].content.toString();

    const messageId = uuidv4();
    const timestamp = Date.now();

    await agentState.addToHistory({
      id: messageId,
      userId: undefined,
      timestamp: timestamp,
      userMessage: undefined,
      llmMessage: `${SUMMARY_MESSAGE_PREFIX}${result}`,
      agentClient: AgentClientsEnum.WEB
    });
  } catch (error) {
    console.error('Agent error:', error);
  }

}