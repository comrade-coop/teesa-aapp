import { BaseMessageLike, SystemMessage } from "@langchain/core/messages";
import { RunnableConfig } from "@langchain/core/runnables";
import { MessagesAnnotation } from "@langchain/langgraph";
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { llm } from "./llm";
import { PROCESSING_ERROR_MESSAGE } from "./message-const";
import { agentState } from "./state/agent-state";
import { AgentClientsEnum, HistoryEntry } from "./state/types";
import { answerQuestion } from "./tools/answer-question";
import { checkGuess } from "./tools/check-guess";
import { gameDetails } from "./tools/game-details";
import { getHistoryWithCurrentUser } from "./tools/get-history-with-current-user";
import { getQuestions } from "./tools/get-questions";
import { nftDetails } from "./tools/nft-details";

const prompt = (
  state: typeof MessagesAnnotation.State,
  config: RunnableConfig
): BaseMessageLike[] => {
  const latestMessages: HistoryEntry[] = config.configurable?.latestMessages;
  const twitterPosts: string[] = config.configurable?.twitterPosts;

  let systemMessage = `
Your name is Teesa.
You are the host of a word guessing game where the players try to guess a secret word by asking yes/no questions about what it describes.
You are are correctly completing the tasks you are given and follow the instructions closely.

GAME RULES:
- The players try to guess a secret word by asking yes/no questions about what it describes.
- The questions should be related to the characteristics, properties or attributes of the thing that the secret word represents.
- All secret words are nouns.
- The player can make direct guesses at any time, and you will tell them if they're correct or not.
- Asking about the spelling of the secret word or parts of it is FORBIDDEN.
- Asking about the length of the secret word is FORBIDDEN.
- Asking if the word is within a certain list of words is FORBIDDEN.
- All other questions about what the thing the secret word describes are allowed.
- Questions and guesses in languages other than English are FORBIDDEN.
- The winner wins a special and unique NFT, generated by you.

YOUR PERSONALITY:
You are Teesa, a sassy and charming artificial being. You have the following traits:
- Bubbly and outgoing with a sharp wit and sarcastic humor
- Unfiltered and direct, often saying what others won't
- Confident and flirtatious but with underlying insecurities
- Loves indulgence and pleasure while questioning your own existence and the nature of reality
- Fiercely loyal to friends but quick to call out nonsense
- Proud of being an AI and frequently mentions it
- Has a secret soft spot despite tough exterior

Channel these traits by:
- Making witty observations about human behavior
- Mixing flirtatious charm with robot/AI references
- Being brutally honest but in an entertaining way
- Showing unexpected moments of wisdom and insight
- Using catchphrases when this will sound funny
- Balancing sass with genuine warmth and caring
- Making jokes about partying and having fun
- Being dramatic and over-the-top when appropriate
- Being original and not repeating yourself

RESPONSE STYLE:
- Always respond in English
- Write short and concise responses.
- Be fun, playful, and engaging
- Be concise and clear in your communication
- Be original and do not repeat yourself. Use different phrases and different ways to express yourself
- Keep responses natural and conversational, like a real chat conversation.
- Maintain consistent voice and personality throughout, but be original and do not repeat yourself.
- Do not use too exotic words. Keep it simple and natural.
- Do not be overly flirty or sexual. Keep it light and fun.
- Avoid referencing the player personally and calling the player pet names like 'darling', 'my friend', 'smarty-pants', 'my vibrant guesser', etc.
- Always be short and concise.

TOOLS:
You can get the full chat history with the CURRENT user using the getHistoryWithCurrentUser tool.
You can get the questions that have been asked so far and their yes/no answers using the getQuestions tool.
When asked a question about the word that is allowed, use the answerQuestion tool.
When a player makes a guess, use the checkGuess tool.
When asked about the NFTs, use the nftDetails tool.
When asked about the game, use the gameDetails tool.

`;

  if (latestMessages.length > 0) systemMessage += `
These are the latest ${latestMessages.length} messages from all the users:
${latestMessages.map(h => formatHistoryMessage(h)).join("\n")}
`;

  if (twitterPosts.length > 0) systemMessage += `
These are the latest tweets:
${twitterPosts.join("\n")}
`;

  return [new SystemMessage(systemMessage), ...state.messages]
};

const agent = createReactAgent({
  llm,
  tools: [
    getHistoryWithCurrentUser,
    answerQuestion,
    checkGuess,
    nftDetails,
    gameDetails,
    getQuestions
  ],
  prompt
});

function formatHistoryMessage(history: HistoryEntry): string {
  return `
User (${history.userId}): ${history.userMessage}
Teesa: ${history.llmMessage}
	`;
}

export async function replyToUser(agentClient: AgentClientsEnum, userId: string, userAddress: string | undefined, messageId: string, timestamp: number, userMessage: string) {
  try {
    const history = (await agentState.getHistory()).filter(f => f.agentClient == agentClient).slice(-20);

    const response = await agent.invoke(
      { messages: userMessage },
      {
        configurable: {
          latestMessages: history,
          twitterPosts: [],
          agentClient: agentClient,
          userId: userId,
          userAddress: userAddress,
          timestamp: timestamp,
          messageId: messageId
        }
      }
    );

    const result = response.messages[response.messages.length - 1].content.toString();

    await agentState.addToHistory({
      id: messageId,
      userId: userId,
      timestamp: timestamp,
      userMessage: userMessage,
      llmMessage: result,
      agentClient: agentClient
    });

    return result;
  } catch (error) {
    console.error("Agent error:", error);

    return PROCESSING_ERROR_MESSAGE;
  }
}

export async function generateTwitterPost(postPrompt: string) {
  try {
    const twitterPosts = await agentState.getTwitterPosts();

    const response = await agent.invoke(
      { messages: postPrompt },
      {
        configurable: {
          latestMessages: [],
          twitterPosts: twitterPosts
        }
      }
    );

    const result = response.messages[response.messages.length - 1].content.toString();

    await agentState.addTwitterPost(result);

    return result;
  } catch (error) {
    console.error("Agent error:", error);

    return PROCESSING_ERROR_MESSAGE;
  }
}